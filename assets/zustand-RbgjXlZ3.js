import{a as H}from"./react-DEe3I7kj.js";import{u as D}from"./use-sync-external-store-BaPpfn7J.js";const z={},_=n=>{let a;const o=new Set,s=(f,y)=>{const m=typeof f=="function"?f(a):f;if(!Object.is(m,a)){const S=a;a=y??(typeof m!="object"||m===null)?m:Object.assign({},a,m),o.forEach(p=>p(a,S))}},c=()=>a,d={setState:s,getState:c,getInitialState:()=>l,subscribe:f=>(o.add(f),()=>o.delete(f)),destroy:()=>{(z?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),o.clear()}},l=a=n(s,c,d);return d},F=n=>n?_(n):_,E={},{useDebugValue:P}=H,{useSyncExternalStoreWithSelector:T}=D;let I=!1;const C=n=>n;function j(n,a=C,o){(E?"production":void 0)!=="production"&&o&&!I&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),I=!0);const s=T(n.subscribe,n.getState,n.getServerState||n.getInitialState,a,o);return P(s),s}const x=n=>{(E?"production":void 0)!=="production"&&typeof n!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const a=typeof n=="function"?F(n):n,o=(s,c)=>j(a,s,c);return Object.assign(o,a),o},$=n=>x,A={};function J(n,a){let o;try{o=n()}catch{return}return{getItem:c=>{var t;const g=d=>d===null?null:JSON.parse(d,void 0),v=(t=o.getItem(c))!=null?t:null;return v instanceof Promise?v.then(g):g(v)},setItem:(c,t)=>o.setItem(c,JSON.stringify(t,void 0)),removeItem:c=>o.removeItem(c)}}const b=n=>a=>{try{const o=n(a);return o instanceof Promise?o:{then(s){return b(s)(o)},catch(s){return this}}}catch(o){return{then(s){return this},catch(s){return b(s)(o)}}}},N=(n,a)=>(o,s,c)=>{let t={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,u)=>({...u,...r}),...a},g=!1;const v=new Set,d=new Set;let l;try{l=t.getStorage()}catch{}if(!l)return n((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),o(...r)},s,c);const f=b(t.serialize),y=()=>{const r=t.partialize({...s()});let u;const e=f({state:r,version:t.version}).then(h=>l.setItem(t.name,h)).catch(h=>{u=h});if(u)throw u;return e},m=c.setState;c.setState=(r,u)=>{m(r,u),y()};const S=n((...r)=>{o(...r),y()},s,c);let p;const i=()=>{var r;if(!l)return;g=!1,v.forEach(e=>e(s()));const u=((r=t.onRehydrateStorage)==null?void 0:r.call(t,s()))||void 0;return b(l.getItem.bind(l))(t.name).then(e=>{if(e)return t.deserialize(e)}).then(e=>{if(e)if(typeof e.version=="number"&&e.version!==t.version){if(t.migrate)return t.migrate(e.state,e.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return e.state}).then(e=>{var h;return p=t.merge(e,(h=s())!=null?h:S),o(p,!0),y()}).then(()=>{u==null||u(p,void 0),g=!0,d.forEach(e=>e(p))}).catch(e=>{u==null||u(void 0,e)})};return c.persist={setOptions:r=>{t={...t,...r},r.getStorage&&(l=r.getStorage())},clearStorage:()=>{l==null||l.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>i(),hasHydrated:()=>g,onHydrate:r=>(v.add(r),()=>{v.delete(r)}),onFinishHydration:r=>(d.add(r),()=>{d.delete(r)})},i(),p||S},L=(n,a)=>(o,s,c)=>{let t={storage:J(()=>localStorage),partialize:i=>i,version:0,merge:(i,r)=>({...r,...i}),...a},g=!1;const v=new Set,d=new Set;let l=t.storage;if(!l)return n((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),o(...i)},s,c);const f=()=>{const i=t.partialize({...s()});return l.setItem(t.name,{state:i,version:t.version})},y=c.setState;c.setState=(i,r)=>{y(i,r),f()};const m=n((...i)=>{o(...i),f()},s,c);c.getInitialState=()=>m;let S;const p=()=>{var i,r;if(!l)return;g=!1,v.forEach(e=>{var h;return e((h=s())!=null?h:m)});const u=((r=t.onRehydrateStorage)==null?void 0:r.call(t,(i=s())!=null?i:m))||void 0;return b(l.getItem.bind(l))(t.name).then(e=>{if(e)if(typeof e.version=="number"&&e.version!==t.version){if(t.migrate)return[!0,t.migrate(e.state,e.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,e.state];return[!1,void 0]}).then(e=>{var h;const[w,R]=e;if(S=t.merge(R,(h=s())!=null?h:m),o(S,!0),w)return f()}).then(()=>{u==null||u(S,void 0),S=s(),g=!0,d.forEach(e=>e(S))}).catch(e=>{u==null||u(void 0,e)})};return c.persist={setOptions:i=>{t={...t,...i},i.storage&&(l=i.storage)},clearStorage:()=>{l==null||l.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>p(),hasHydrated:()=>g,onHydrate:i=>(v.add(i),()=>{v.delete(i)}),onFinishHydration:i=>(d.add(i),()=>{d.delete(i)})},t.skipHydration||p(),S||m},O=(n,a)=>"getStorage"in a||"serialize"in a||"deserialize"in a?((A?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),N(n,a)):L(n,a),k=O;export{J as a,$ as c,k as p};
